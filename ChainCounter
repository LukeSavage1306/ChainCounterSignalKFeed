#include <Arduino.h>

//#define SERIAL_DEBUG_DISABLED

#include "sensesp_app.h"
#include "sensors/digital_input.h"
#include "signalk/signalk_output.h"


// SensESP builds upon the ReactESP framework. Every ReactESP application
// defines an "app" object vs defining a "main()" method.
ReactESP app([]() {
#ifndef SERIAL_DEBUG_DISABLED
  SetupSerialDebug(115200);
#endif

  sensesp_app = new SensESPApp();

  // The "Signal K path" identifies the output of the sensor to the Signal K
  // network. If you have multiple sensors connected to your microcontoller
  // (ESP), each one of them will (probably) have its own Signal K path variable.
  // For example, if you have two propulsion engines, and you want the RPM of
  // each of them to go to Signal K, you might have sk_path_portEngine =
  // "propulsion.port.revolutions" and sk_path_starboardEngine =
  // "propulsion.starboard.revolutions" In this example, there is only one
  // propulsion engine, and its RPM is the only thing being reported to Signal K.
  // To find valid Signal K Paths that fits your need you look at this link:
  // https://signalk.org/specification/1.4.0/doc/vesselsBranch.html  
  const char* sk_path = "propulsion.anchor.chainlength";

  // The "Configuration path" is combined with "/config" to formulate a URL
  // used by the RESTful API for retrieving or setting configuration data.
  // It is ALSO used to specify a path to the SPIFFS file system
  // where configuration data is saved on the microcontroller.  It should
  // ALWAYS start with a forward slash if specified. If left blank,
  // that indicates this sensor or transform does not have any
  // configuration to save.
  
  const char* config_path = "/sensors/engine_rpm";

  // These two are necessary until a method is created to synthesize them.
  // Everything after "/sensors" in each of these ("/engine_rpm/calibrate" and
  // "/engine_rpm/sk") is simply a label to display what you're configuring in
  // the Configuration UI.
  const char* config_path_calibrate = "/sensors/engine_rpm/calibrate";
  const char* config_path_skpath = "/sensors/engine_rpm/sk";

#include<ESP8266WiFi.h>
#include<ESP8266WebServer.h>
#include<EEPROM.h>

#include "index_html.h"              // Web site information for Gauge / Buttons

#define ENABLE_DEMO 0                // Set to 1 to enable Demo Mode with up/down counter JCHP changed to 0
#define SAFETY_STOP 2                // Defines safety stop for chain up. Stops defined number of events before reaching zero
#define MAX_CHAIN_LENGTH 40          // Define maximum chan length. Relay off after the value is reached

// Wifi: Select AP or Client

#define WiFiMode_AP_STA 1            // Defines WiFi Mode 0 -> AP (with IP:192.168.4.1 and  1 -> Station (client with IP: via DHCP)
const char *ssid = "Capacity";     // Set WLAN name
const char *password = "Capacity2716";  // Set password

ESP8266WebServer server(80);                // Web Server at port 80


// Chain Counter

#define Chain_Calibration_Value 0.33 // Translates counter impuls to meter 0,33 m per pulse
#define Chain_Counter_Pin D1         // Counter impulse is measured as interrupt on pin D1, GPIO pin 05
unsigned long Last_int_time = 0;     // Time of last interrupt
unsigned long Last_event_time = 0;   // Time of last event for engine watchdog
int ChainCounter = 0;                // Counter for chain events
int LastSavedCounter = 0;            // Stores last ChainCounter value to allow storage to nonvolatile storage in case of value changes

// Relay

#define Chain_Up_Pin D7              // GPIO pin 13 for Chain Up Relay
#define Chain_Down_Pin D5            // GPIO pin 14 for Chain Down Relay
#define Chain_Up_Override_Pin D2     // GPIO pin 04 for Chain Up Override
#define Chain_Down_Override_Pin D6   // GPIO pin 12 for Chain Down Override 
int UpDown = 1;                      // 1 =  Chain down / count up, -1 = Chain up / count backwards
int OnOff = 0;                       // Relay On/Off - Off = 0, On = 1
unsigned long Watchdog_Timer = 0;    // Watchdog timer to stop relay after 1 second of inactivity e.g. connection loss to client


// Chain Event Interrupt
// Enters on falling edge

void IRAM_ATTR handleInterrupt() {
  noInterrupts();

  if (millis() > Last_int_time + 10) {  // Debouncing. No new events for 10 milliseconds

    ChainCounter += UpDown;             // Chain event: Count up/down

    if ( ( (ChainCounter <= SAFETY_STOP) && (UpDown == -1) && (OnOff == 1) ) ||     // Safety stop counter reached while chain is going up
         ( (UpDown == 1) && (abs(ChainCounter) * Chain_Calibration_Value >= MAX_CHAIN_LENGTH) ) ) {  // Maximum chain lenght reached

      digitalWrite(Chain_Up_Pin, LOW );
      digitalWrite(Chain_Down_Pin, LOW );
      OnOff = 0;
    }
    Last_event_time = millis();         // Store last event time to detect blocking chain
  }
  Last_int_time = millis();             // Store last interrupt time for debouncing
  interrupts();
}


void setup() {
  
  // LED indicator
  pinMode(LED_BUILTIN,OUTPUT); //Define LED pin as output
  digitalWrite(LED_BUILTIN,HIGH); //and turn it off
  
  int wifi_retry = 0;

  // Relay output
  pinMode(Chain_Up_Pin, OUTPUT);            // Sets pin as output
  pinMode(Chain_Down_Pin, OUTPUT);          // Sets pin as output
  digitalWrite(Chain_Up_Pin, LOW );         // Relay off
  digitalWrite(Chain_Down_Pin, LOW );       // Relay off
  
  //Over Ride input
  pinMode(Chain_Down_Override_Pin, INPUT_PULLUP);  // Sets pin as input pulled high JCHP changed from digitalWrite to pinMode
  pinMode(Chain_Up_Override_Pin, INPUT_PULLUP);    // Sets pin as input pulled high JCHP changed from digitalWrite to pinMode
  

  // Init Chain Count measure with interrupt
  pinMode(Chain_Counter_Pin, INPUT_PULLUP); // Sets pin input with pullup resistor
  attachInterrupt(digitalPinToInterrupt(Chain_Counter_Pin), handleInterrupt, FALLING); // Attaches pin to interrupt on falling edge

  // Init serial
  Serial.begin(115200);
  Serial.print("");
  Serial.println("Start");

  EEPROM.begin(16);
  ChainCounter = EEPROM.read(0);
  LastSavedCounter = ChainCounter;                  // Initialise last counter value

  // Init WLAN AP
  if (WiFiMode_AP_STA == 0) {

    WiFi.mode(WIFI_AP);                              // WiFi Mode Access Point
    delay (100);
    WiFi.softAP(ssid, password); // AP name and password
    Serial.println("Start WLAN AP");
    Serial.print("IP address: ");
    Serial.println(WiFi.softAPIP());

  } else {

    Serial.println("Start WLAN Client DHCP");         // WiFi Mode Client with DHCP
    WiFi.begin(ssid, password);

    while (WiFi.status() != WL_CONNECTED) {           // Check connection
      wifi_retry++;
      delay(500);
      Serial.print(".");
      if (wifi_retry > 10) {
        Serial.println("\nReboot");                   // Reboot after 10 connection tries
        ESP.restart();
      }
    }

    Serial.println("");
    Serial.println("WiFi connected");
    Serial.println("IP address: ");
    Serial.println(WiFi.localIP());
  }


  // Handle HTTP request events

  server.on("/", Event_Index);
  server.on("/gauge.min.js", Event_js);
  server.on("/ADC.txt", Event_ChainCount);
  server.on("/up", Event_Up);
  server.on("/down", Event_Down);
  server.on("/stop", Event_Stop);
  server.on("/reset", Event_Reset);

  server.onNotFound(handleNotFound);

  server.begin();
  Serial.println("HTTP Server started");
}


void Event_Up() {                          // Handle UP request
  if ((OnOff == 0) && (digitalRead(Chain_Up_Override_Pin) == HIGH) && (digitalRead(Chain_Down_Override_Pin) == HIGH)) {

  server.send(200, "text/plain", "-1000"); // Send response "-1000" means no  chainlength
  Serial.println("Up");
  digitalWrite(Chain_Up_Pin, HIGH );
  digitalWrite(Chain_Down_Pin, LOW );
  Last_event_time = millis();
  UpDown = -1;
  OnOff = 1;
}
}

void Event_Down() {                         // Handle Down request
  if ((OnOff == 0) && (digitalRead(Chain_Up_Override_Pin) == HIGH) && (digitalRead(Chain_Down_Override_Pin) == HIGH)) {
  server.send(200, "text/plain", "-1000");  // Send response "-1000" means no  chainlength
  Serial.println("Down");
  digitalWrite(Chain_Up_Pin, LOW );
  digitalWrite(Chain_Down_Pin, HIGH );
  Last_event_time = millis();
  UpDown = 1;
  OnOff = 1;
}
}

void Event_Stop() {                         // Handle Stop request

  server.send(200, "text/plain", "-1000");  // Send response "-1000" means no  chainlength
  Serial.println("Stop");
  digitalWrite(Chain_Up_Pin, LOW );
  digitalWrite(Chain_Down_Pin, LOW );
  OnOff = 0;
//}}
}

void Event_Reset() {                        // Handle reset request to reset counter to 0
  ChainCounter = 0;
  server.send(200, "text/plain", "-1000");  // Send response "-1000" means no  chainlenght
  Serial.println("Reset");
}


void Event_Index() {                         // If "http://<ip address>/" requested
  server.send(200, "text/html", indexHTML);  // Send Index Website
}


void Event_js() {                            // If "http://<ip address>/gauge.min.js" requested
  server.send(200, "text/html", gauge);      // Then send gauge.min.js
}


void Event_ChainCount() {                    // If  "http://<ip address>/ADC.txt" requested
  
  float temp = (ChainCounter * Chain_Calibration_Value); // Chain in meters
  server.sendHeader("Cache-Control", "no-cache");
  server.send(200, "text/plain", String (temp));

  Watchdog_Timer = millis();                 // Watchdog timer is set to current uptime

#if ENABLE_DEMO == 1                         // Demo Mode - Counts automatically UP/Down every 500 ms

  if (OnOff == 1) ChainCounter += UpDown;

  if ( ( (ChainCounter <= SAFETY_STOP) && (UpDown == -1) && (OnOff == 1) ) ||     // Safety stop counter reached while chain is going up
       ( (UpDown == 1) && (abs(ChainCounter) * Chain_Calibration_Value >= MAX_CHAIN_LENGTH) ) ) {  // Maximum chain lenght reached

    digitalWrite(Chain_Up_Pin, LOW );
    digitalWrite(Chain_Down_Pin, LOW );
    OnOff = 0;
  }
  Last_event_time = millis();
#endif

}


void handleNotFound() {                                           // Unknown request. Send error 404
  server.send(404, "text/plain", "File Not Found\n\n");
}


void loop() {
  int wifi_retry = 0;

  server.handleClient();                                           // Handle HTTP requests

  if ( ( millis() > Watchdog_Timer + 1000 ) ||                     // Check HTTP connnection
       ( (OnOff == 1) && (millis() > Last_event_time + 1000)) )  { // Check events if engine is on

//    digitalWrite(Chain_Up_Pin, LOW );                              // Relay off after 1 second inactivity  JCHP commented out
//    digitalWrite(Chain_Down_Pin, LOW );                            // JCHP commented out
//    OnOff = 0;                                                     // JCHP commented out
  }
  
  if ((OnOff == 1 && (digitalRead(Chain_Up_Override_Pin) == LOW))||(OnOff == 1&& (digitalRead(Chain_Down_Override_Pin)) == LOW)){  //If the app is on and one of the relays is operated
    digitalWrite(BUILTIN_LED,LOW);                                                      // then turn on the LED
  } else {                                                                              // otherwis
    digitalWrite(BUILTIN_LED,HIGH);                                                     // turn it off 
  }
  
  if (OnOff == 0) {                                     // If App is off  ... 
  if (digitalRead(Chain_Up_Override_Pin) == LOW) {      // and there is a manual chain up over-ride 
  UpDown = -1;                                          // set counter to reduce chain count
  } else {
  UpDown = 1;                                           // otherwise if App is off then set to increase counter ie free fall or powered down..
  }}
    

  if (ChainCounter != LastSavedCounter) {                          // Store Chain Counter to nonvolatile storage (if changed)
    EEPROM.write(0, ChainCounter);
    EEPROM.commit();
    LastSavedCounter = ChainCounter;
  }

  if (WiFiMode_AP_STA == 1) {                                      // Check connection if working as client
    while (WiFi.status() != WL_CONNECTED && wifi_retry < 5 ) {     // Connection lost, 5 tries to reconnect
      wifi_retry++;
      Serial.println("WiFi not connected. Try to reconnect");
      WiFi.disconnect();
      WiFi.mode(WIFI_OFF);
      WiFi.mode(WIFI_STA);
      WiFi.begin(ssid, password);
      delay(100);
    }
    if (wifi_retry >= 5) {
      Serial.println("\nReboot");                                  // Did not work -> restart ESP32
      ESP.restart();
    }
  }
  
  Chaincounter

      ->connect_to(new SKOutputNumber(
          sk_path, config_path_skpath));  // connect the output of Frequency()
                                          // to a Signal K Output as a number
  
  // Dummy to empty input buffer to avoid board to stuck with e.g. NMEA Reader
  
  if ( Serial.available() ) {
    Serial.read();
  }
}



  // Start the SensESP application running. Because of everything that's been
  // set up above, it constantly monitors the interrupt pin, and every
  // read_delay ms, it sends the calculated frequency to Signal K.
  sensesp_app->enable();
});
